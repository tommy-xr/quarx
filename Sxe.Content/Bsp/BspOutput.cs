//using System;
//using System.Collections.Generic;
//using System.Text;

//using Microsoft.Xna.Framework;
//using Microsoft.Xna.Framework.Content.Pipeline.Graphics;
//using Microsoft.Xna.Framework.Content.Pipeline;
//using Microsoft.Xna.Framework.Content.Pipeline.Serialization.Compiler;

//using Sxe.Library.Bsp;
//using Sxe.Library.Utilities;


//namespace Sxe.Content.Bsp
//{



//    /// <summary>
//    /// Output data generated by BSP Processor
//    /// </summary>
//    public class BspOutput
//    {
//        //We'll keep a copy of all the data in the object model
//        BspDom Dom;

//        List<BspFaceGroup> facegroups;
//        List<BspVertex> vertexes;
//        List<int> indices;
//        List<ExternalReference<Texture2DContent>> textures;

//        public BspOutput(BspDom inDom, ContentProcessorContext context)
//        {
//            vertexes = new List<BspVertex>();
//            indices = new List<int>();
//            facegroups = new List<BspFaceGroup>();


//            Dom = inDom;

//            CreateBinormalsAndTangents();

//            CreateFacegroups();

//            textures = CreateTextures(context);
//        }

//        List<ExternalReference<Texture2DContent>> CreateTextures(ContentProcessorContext context)
//        {
//            List<ExternalReference<Texture2DContent>> textureList = new List<ExternalReference<Texture2DContent>>();
//            for (int i = 0; i < Dom.Textures.Count; i++)
//            {
//                ExternalReference<Texture2DContent> texture = context.BuildAsset<Texture2DContent, Texture2DContent>(
//                    new ExternalReference<Texture2DContent>(FindExtension(Dom.Textures[i].textureName)), null);
//                textureList.Add(texture);
//            }
//            return textureList;
//        }

//       string FindExtension(string path)
//        {
//            string[] extensions = new string[] { ".jpg", ".tga", ".png" };

//            foreach (string extension in extensions)
//            {
//                if(FileUtilities.FileExists(path + extension))
//                    return path + extension;
//            }

//           throw new Exception("Could not find file: " + path);
//        }

//        public void Write(ContentWriter writer)
//        {
//            //Write the facegroups
//            writer.Write(facegroups.Count);
//            foreach (BspFaceGroup fg in facegroups)
//                fg.Write(writer);

//            //Write the vertices
//            writer.Write(vertexes.Count);
//            foreach (BspVertex v in vertexes)
//                WriteVertex(writer, v);
            
//            //Write the indices
//            writer.Write(indices.Count);
//            foreach (int i in indices)
//                writer.Write((int)i);

//            //Write the textures
//            writer.Write(textures.Count);
//            foreach (ExternalReference<Texture2DContent> texture in textures)
//                writer.WriteExternalReference<Texture2DContent>(texture);

//            //Finally, write the DOM
//            Dom.Write(writer);


//        }

//        static void WriteVertex(ContentWriter cw, BspVertex vert)
//        {
//            cw.Write(vert.Position);
//            cw.Write(vert.Normal);
//            cw.Write(vert.Binormal);
//            cw.Write(vert.Tangent);
//            cw.Write(vert.DiffuseTexCoords);
//            cw.Write(vert.LightTexCoords);
//        }

//        /// <summary>
//        /// Generate tangents and binormals for faces
//        /// </summary>
//        public void CreateBinormalsAndTangents()
//        {
//            for (int i = 0; i < Dom.Faces.Count; i++)
//            {
//                if (Dom.Faces[i].numberOfMeshVertexes <= 0 || Dom.Faces[i].type == 2) //if face is a patch, skip
//                    continue;

//                BspVertexes v1 = Dom.Vertexes[Dom.Faces[i].vertex + Dom.MeshVertexes[Dom.Faces[i].meshVertex].offset];

//                BspVertexes v2 = Dom.Vertexes[Dom.Faces[i].vertex + Dom.MeshVertexes[Dom.Faces[i].meshVertex + 1].offset];

//                BspVertexes v3 = Dom.Vertexes[Dom.Faces[i].vertex + Dom.MeshVertexes[Dom.Faces[i].meshVertex + 2].offset];

//                Vector3 tangent;
//                Vector3 binormal;

//                MeshUtilities.CalculateTBN(v1.position, v2.position, v3.position,
//                    v1.texCoords[0], v2.texCoords[0], v3.texCoords[0],
//                    Dom.Faces[i].normal, out tangent, out binormal);


//                Dom.Faces[i].tangent = tangent;
//                Dom.Faces[i].binormal = binormal;
//            }
//        }

//        /// <summary>
//        /// Do the work of combining the facegroups together
//        /// </summary>
//        void CreateFacegroups()
//        {
//            for (int k = 0; k < Dom.Models.Count; k++)
//            {

//                for (int i = 0; i <= Dom.LightMaps.Count; i++)
//                {
//                    for (int j = 0; j < Dom.Textures.Count; j++)
//                    {
//                        ModelAdd(k, j, i);
//                    }
//                }
//            }
//        }


//        void ModelAdd(int model, int texIndex, int lightIndex)
//        {

//            //Get starting face
//            int start_face = Dom.Models[model].face;
//            //Get the number of faces the model has
//            int num_faces = Dom.Models[model].numberOfFaces;

//            for (int i = start_face; i < start_face + num_faces; i++)
//            {
//                if (Dom.Faces[i].texture == texIndex && Dom.Faces[i].lm_index == lightIndex && Dom.Faces[i].faceGroup == -1)
//                {
//                    ProcessFace(i, model);
//                }
//            }
//        }

//        /// <summary>
//        /// Go through the face and add all the vertices and indices
//        /// </summary>
//        void ProcessFace(int faceIndex, int modelIndex)
//        {
//            BspFace face = Dom.Faces[faceIndex];

//            //If face is a patch, skip for now
//            if (face.type == 2)
//                return;


//            BspFaceGroup currentFaceGroup = GetFaceGroup(face.texture, face.lm_index, modelIndex);

//            if (currentFaceGroup.startOffset < 0)
//                currentFaceGroup.startOffset = indices.Count;

//            if (currentFaceGroup.startVertex < 0)
//                currentFaceGroup.startVertex = vertexes.Count;


//            face.faceGroup = currentFaceGroup.index;

//            //Create some index info
//            int[] tempIndices = new int[Dom.Vertexes.Count];

//            for (int i = 0; i < tempIndices.Length; i++)
//                tempIndices[i] = -1;

//            //Now, go through vertices, and add to vertex buffer, calculating binormals and tangents along the way
//            for (int i = 0; i < face.numberOfMeshVertexes; i++)
//            {
//                int index = face.vertex + Dom.MeshVertexes[face.meshVertex + i].offset;

//                //If we haven't seen this vertex index before, add it 
//                if (tempIndices[index] == -1)
//                {
//                    //Create this vertex, and add it to vertex list. Also, save our index away
//                    BspVertexes vertex = Dom.Vertexes[index];
//                    BspVertex vert = new BspVertex(vertex.position, face.normal, face.binormal, face.tangent, vertex.texCoords[0], vertex.texCoords[1]);
//                    vertexes.Add(vert);
//                    tempIndices[index] = (int)(vertexes.Count - 1);
//                }

//                currentFaceGroup.numberOfIndexes++;
//                indices.Add(tempIndices[index]);

//            }

//            currentFaceGroup.numberOfFaces++;

//        }

//        /// <summary>
//        /// Find the facegroup a face should belong to. This also handles creating a new facegroup,
//        /// if a suitable one does not exist
//        /// </summary>
//        BspFaceGroup GetFaceGroup(int texture, int lightmap, int model)
//        {
//            //Dumb algorithm, just loop through facegroups.
//            //If a facegroup is around that satisfies criteria, kickass
//            //Otherwise create a new one
//            //Check if we have a current face group we are working on
//            for (int i = 0; i < facegroups.Count; i++)
//            {
//                if (facegroups[i].texIndex == texture && facegroups[i].model == model && facegroups[i].lmIndex == lightmap && facegroups[i].numberOfFaces < BspConstants.MaxFaceGroupFaces)
//                {
//                    return facegroups[i];
//                }
//            }

//            BspFaceGroup currentFaceGroup = new BspFaceGroup();

//            currentFaceGroup.texIndex = texture;
//            currentFaceGroup.lmIndex = lightmap;
//            currentFaceGroup.model = model;
//            currentFaceGroup.startOffset = -1;
//            currentFaceGroup.startVertex = -1;
//            currentFaceGroup.numberOfIndexes = 0;
//            currentFaceGroup.numberOfFaces = 0;
//            currentFaceGroup.index = facegroups.Count;

//            facegroups.Add(currentFaceGroup);


//            return currentFaceGroup;
//        }


//    }
//}
